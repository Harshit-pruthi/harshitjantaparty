<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tic Tac Toe - Game Lobby</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Oxanium:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
   <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      transition: all 0.3s ease;
    }

    body {
      font-family: 'Oxanium', sans-serif;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      color: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 30px;
      min-height: 100vh;
      overflow-x: hidden;
    }

    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 3rem;
      color: #00d9ff;
      text-shadow: 0 0 20px #00d9ff;
      margin-bottom: 20px;
      animation: glow 2s infinite alternate;
    }

    @keyframes glow {
      0% { text-shadow: 0 0 10px #00d9ff; }
      100% { text-shadow: 0 0 30px #00d9ff, 0 0 40px #00d9ff; }
    }

    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 1000px;
      margin-bottom: 20px;
      animation: fadeIn 0.8s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .party-info {
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .party-info p {
      margin: 5px 0;
      font-size: 0.9rem;
    }

    .party-info strong {
      color: #00d9ff;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 1000px;
      gap: 30px;
    }

    .game-board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 12px;
      width: 100%;
      max-width: 500px;
      aspect-ratio: 1/1;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 217, 255, 0.3);
    }

    .cell {
      background: #1a1a2e;
      border-radius: 8px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 4rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      aspect-ratio: 1/1;
    }

    .cell:hover {
      background: rgba(0, 217, 255, 0.1);
      transform: scale(1.03);
    }

    .cell.x {
      color: #ff2a6d;
      text-shadow: 0 0 15px rgba(255, 42, 109, 0.7);
    }

    .cell.o {
      color: #05d9e8;
      text-shadow: 0 0 15px rgba(5, 217, 232, 0.7);
    }

    .status-container {
      background: rgba(0, 0, 0, 0.6);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
      width: 100%;
      max-width: 500px;
      text-align: center;
    }

    .game-status {
      font-size: 1.5rem;
      margin-bottom: 15px;
      color: #00d9ff;
    }

    .player-turn {
      font-size: 1.2rem;
      margin-bottom: 15px;
    }

    .player-turn.x {
      color: #ff2a6d;
    }

    .player-turn.o {
      color: #05d9e8;
    }

    .players-container {
      background: rgba(0, 0, 0, 0.6);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
      width: 100%;
      max-width: 400px;
    }

    .players-container h3 {
      text-align: center;
      margin-bottom: 15px;
      color: #00d9ff;
    }

    .player-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .player-item {
      display: flex;
      align-items: center;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      gap: 10px;
    }

    .player-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff2a6d, #05d9e8);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 1.2rem;
    }

    .player-name {
      flex-grow: 1;
    }

    .player-symbol {
      font-size: 1.5rem;
      font-weight: bold;
      width: 30px;
      text-align: center;
    }

    .player-symbol.x {
      color: #ff2a6d;
    }

    .player-symbol.o {
      color: #05d9e8;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }

    button {
      padding: 12px 20px;
      background: linear-gradient(135deg, #ff2a6d, #05d9e8);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 255, 255, 0.2);
    }

    button.secondary {
      background: transparent;
      border: 2px solid #05d9e8;
    }

    .winning-cell {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
      50% { box-shadow: 0 0 20px rgba(0, 217, 255, 0.8); }
      100% { box-shadow: 0 0 5px rgba(255, 255, 255, 0.5); }
    }
    
    .winner-display {
      font-size: 2rem;
      text-align: center;
      margin-top: 20px;
      padding: 15px;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.7);
      animation: winnerPulse 2s infinite;
    }
    
    @keyframes winnerPulse {
      0% { 
        text-shadow: 0 0 5px #fff, 0 0 10px #fff;
        transform: scale(1);
      }
      50% { 
        text-shadow: 0 0 20px #ff0, 0 0 30px #ff0;
        transform: scale(1.05);
      }
      100% { 
        text-shadow: 0 0 5px #fff, 0 0 10px #fff;
        transform: scale(1);
      }
    }
    
    .score-board {
      display: flex;
      justify-content: space-around;
      width: 100%;
      max-width: 500px;
      margin-top: 20px;
    }
    
    .score-box {
      background: rgba(0, 0, 0, 0.6);
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      min-width: 120px;
    }
    
    .score-box.x {
      border: 2px solid #ff2a6d;
    }
    
    .score-box.o {
      border: 2px solid #05d9e8;
    }
    
    .score-value {
      font-size: 2rem;
      font-weight: bold;
      margin-top: 5px;
    }
    
    .x .score-value {
      color: #ff2a6d;
    }
    
    .o .score-value {
      color: #05d9e8;
    }
    
    .player-indicator {
      font-size: 0.9rem;
      margin-top: 5px;
      font-style: italic;
    }
    
    .notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 42, 109, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      z-index: 1000;
      animation: slideDown 0.5s ease-out;
    }

    @keyframes slideDown {
      from { top: -50px; opacity: 0; }
      to { top: 20px; opacity: 1; }
    }
    
    .waiting-message {
      color: #ffcc00;
      font-style: italic;
      margin: 15px 0;
      text-align: center;
    }
    
    .tournament-container {
      background: rgba(0, 0, 0, 0.6);
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
      width: 100%;
      max-width: 500px;
      margin-bottom: 20px;
    }
    
    .tournament-container h3 {
      text-align: center;
      margin-bottom: 15px;
      color: #00d9ff;
    }
    
    .tournament-round {
      margin-bottom: 15px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
    }
    
    .match {
      display: flex;
      justify-content: space-between;
      padding: 8px;
      margin: 5px 0;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
    }
    
    .match.winner {
      background: rgba(0, 255, 0, 0.1);
      border: 1px solid #0f0;
    }
    
    .current-match {
      background: rgba(0, 217, 255, 0.2);
      border: 1px solid #00d9ff;
    }
    
    .afk-warning {
      color: #ffcc00;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="notification" class="notification" style="display: none;"></div>
  
  <div class="header-container">
    <h1><i class="fas fa-times"></i> TIC TAC TOE</h1>
    <div class="party-info">
      <p><strong>Party:</strong> <span id="partyNameDisplay">Game Night</span></p>
      <p><strong>Code:</strong> <span id="partyCodeDisplay">ABCD12</span></p>
      <p><strong>Players:</strong> <span id="playerCount">2</span>/<span id="maxPlayers">4</span></p>
    </div>
  </div>

  <div class="game-container">
    <div class="tournament-container" id="tournamentContainer" style="display: none;">
      <h3><i class="fas fa-trophy"></i> Tournament Bracket</h3>
      <div id="tournamentBracket"></div>
    </div>
    
    <div class="game-board" id="gameBoard">
      <div class="cell" data-index="0"></div>
      <div class="cell" data-index="1"></div>
      <div class="cell" data-index="2"></div>
      <div class="cell" data-index="3"></div>
      <div class="cell" data-index="4"></div>
      <div class="cell" data-index="5"></div>
      <div class="cell" data-index="6"></div>
      <div class="cell" data-index="7"></div>
      <div class="cell" data-index="8"></div>
    </div>
    
    <div class="score-board">
      <div class="score-box x">
        <div>Player X</div>
        <div class="score-value" id="scoreX">0</div>
        <div class="player-indicator" id="playerX">-</div>
      </div>
      <div class="score-box">
        <div>Draws</div>
        <div class="score-value" id="scoreDraw">0</div>
      </div>
      <div class="score-box o">
        <div>Player O</div>
        <div class="score-value" id="scoreO">0</div>
        <div class="player-indicator" id="playerO">-</div>
      </div>
    </div>
    
    <div class="status-container">
      <div class="game-status" id="gameStatus">Game in progress</div>
      <div class="player-turn x" id="playerTurn">Player X's turn</div>
      <div class="controls">
        <button onclick="resetGame()"><i class="fas fa-redo"></i> Reset Game</button>
        <button class="secondary" onclick="leaveGame()"><i class="fas fa-sign-out-alt"></i> Leave Party</button>
      </div>
    </div>
    
    <div class="players-container">
      <h3><i class="fas fa-users"></i> Party Players</h3>
      <div class="player-list" id="playerList">
        <!-- Players will be added here dynamically -->
      </div>
    </div>
  </div>

  <script>
    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyD81BzDBcHWpQHtppO3i5vxX7Zs5iQOuOQ",
      authDomain: "harshitjantaparty-77d46.firebaseapp.com",
      projectId: "harshitjantaparty-77d46",
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // Game state variables
    let currentUser = null;
    let currentParty = null;
    let partyListener = null;
    let gameListener = null;
    let afkTimers = {};
    let gameState = {
      board: Array(9).fill(null),
      currentPlayer: 'X',
      gameStatus: 'playing',
      playerX: null,
      playerO: null,
      scores: { X: 0, O: 0, draw: 0 },
      winningCells: [],
      tournament: {
        rounds: [],
        currentRound: 0,
        currentMatch: 0
      },
      lastMoveTime: null,
      afkPlayers: []
    };

    // DOM Elements
    const gameBoard = document.getElementById('gameBoard');
    const gameStatus = document.getElementById('gameStatus');
    const playerTurn = document.getElementById('playerTurn');
    const playerList = document.getElementById('playerList');
    const partyCodeDisplay = document.getElementById('partyCodeDisplay');
    const partyNameDisplay = document.getElementById('partyNameDisplay');
    const playerCount = document.getElementById('playerCount');
    const maxPlayers = document.getElementById('maxPlayers');
    const scoreX = document.getElementById('scoreX');
    const scoreO = document.getElementById('scoreO');
    const scoreDraw = document.getElementById('scoreDraw');
    const playerXIndicator = document.getElementById('playerX');
    const playerOIndicator = document.getElementById('playerO');
    const notification = document.getElementById('notification');
    const tournamentContainer = document.getElementById('tournamentContainer');
    const tournamentBracket = document.getElementById('tournamentBracket');

    // Show notification
    function showNotification(message) {
      notification.textContent = message;
      notification.style.display = 'block';
      setTimeout(() => {
        notification.style.display = 'none';
      }, 3000);
    }

    // Initialize the game
    function initGame() {
      // Get party code from URL
      const urlParams = new URLSearchParams(window.location.search);
      const partyCode = urlParams.get('partyCode');
      const uid = urlParams.get('uid');
      
      if (!partyCode || !uid) {
        showNotification('Missing parameters. Redirecting to lobby.');
        setTimeout(() => window.location.href = 'index.html', 2000);
        return;
      }
      
      // Set up authentication
      auth.onAuthStateChanged(user => {
        if (user && user.uid === uid) {
          currentUser = user;
          loadParty(partyCode);
        } else {
          // Not authenticated - redirect to lobby
          showNotification('Authentication failed. Redirecting to lobby.');
          setTimeout(() => window.location.href = 'index.html', 2000);
        }
      });
      
      // Set up game board
      setupBoard();
    }
    
    // Load party information
    function loadParty(partyCode) {
      partyListener = db.collection("parties").doc(partyCode).onSnapshot(doc => {
        if (!doc.exists) {
          showNotification('Party not found. Redirecting to lobby.');
          setTimeout(() => window.location.href = 'index.html', 2000);
          return;
        }
        
        currentParty = doc.data();
        updatePartyUI();
        
        // Load game state
        loadGameState(partyCode);
        
        // Assign players if needed
        assignPlayers();
        
        // Setup AFK monitoring
        setupAFKMonitoring();
      });
    }
    
    // Setup AFK monitoring
    function setupAFKMonitoring() {
      // Clear existing timers
      clearAFKTimers();
      
      // Setup AFK timers for each player
      currentParty.players.forEach(player => {
        afkTimers[player.id] = setTimeout(() => {
          markPlayerAFK(player);
        }, 5 * 60 * 1000); // 5 minutes
      });
    }
    
    // Clear all AFK timers
    function clearAFKTimers() {
      Object.values(afkTimers).forEach(timer => clearTimeout(timer));
      afkTimers = {};
    }
    
    // Mark player as AFK
    function markPlayerAFK(player) {
      if (!currentParty || !player) return;
      
      // Add to AFK list
      if (!gameState.afkPlayers.includes(player.id)) {
        gameState.afkPlayers.push(player.id);
        updateGameState();
      }
      
      // Remove player from party
      db.collection("parties").doc(currentParty.code).update({
        players: firebase.firestore.FieldValue.arrayRemove(player)
      });
      
      showNotification(`${player.name} was kicked for being AFK!`);
    }
    
    // Reset AFK timer for player
    function resetAFKTimer(playerId) {
      if (afkTimers[playerId]) {
        clearTimeout(afkTimers[playerId]);
        afkTimers[playerId] = setTimeout(() => {
          const player = currentParty.players.find(p => p.id === playerId);
          if (player) markPlayerAFK(player);
        }, 5 * 60 * 1000);
      }
    }
    
    // Load game state from Firestore
    function loadGameState(partyCode) {
      if (gameListener) gameListener();
      
      gameListener = db.collection("gameStates").doc(partyCode).onSnapshot(doc => {
        if (doc.exists) {
          const data = doc.data();
          gameState = data;
          
          // Initialize tournament if needed
          if (gameState.tournament.rounds.length === 0 && currentParty.players.length >= 2) {
            setupTournament();
          }
          
          updateGameUI();
          updatePartyUI();
          updateTournamentUI();
        } else {
          // Create new game state
          createNewGame(partyCode);
        }
      });
    }
    
    // Setup tournament structure
    function setupTournament() {
      const playerCount = currentParty.players.length;
      gameState.tournament = {
        rounds: [],
        currentRound: 0,
        currentMatch: 0
      };
      
      // Create first round matches
      const firstRoundMatches = [];
      const shuffledPlayers = [...currentParty.players].sort(() => Math.random() - 0.5);
      
      // Create matches for 2, 4, or 8 players
      for (let i = 0; i < shuffledPlayers.length; i += 2) {
        if (i + 1 < shuffledPlayers.length) {
          firstRoundMatches.push({
            player1: shuffledPlayers[i],
            player2: shuffledPlayers[i + 1],
            winner: null
          });
        }
      }
      
      gameState.tournament.rounds.push(firstRoundMatches);
      updateGameState();
    }
    
    // Update tournament UI
    function updateTournamentUI() {
      if (currentParty.players.length < 4) {
        tournamentContainer.style.display = 'none';
        return;
      }
      
      tournamentContainer.style.display = 'block';
      tournamentBracket.innerHTML = '';
      
      gameState.tournament.rounds.forEach((round, roundIndex) => {
        const roundElement = document.createElement('div');
        roundElement.className = 'tournament-round';
        roundElement.innerHTML = `<h4>Round ${roundIndex + 1}</h4>`;
        
        round.forEach((match, matchIndex) => {
          const matchElement = document.createElement('div');
          matchElement.className = 'match';
          
          if (roundIndex === gameState.tournament.currentRound && 
              matchIndex === gameState.tournament.currentMatch) {
            matchElement.classList.add('current-match');
          }
          
          if (match.winner) {
            matchElement.classList.add('winner');
          }
          
          matchElement.innerHTML = `
            <div>${match.player1?.name || 'TBD'}</div>
            <div>VS</div>
            <div>${match.player2?.name || 'TBD'}</div>
            ${match.winner ? `<div>Winner: ${match.winner.name}</div>` : ''}
          `;
          
          roundElement.appendChild(matchElement);
        });
        
        tournamentBracket.appendChild(roundElement);
      });
    }
    
    // Create new game state in Firestore
    function createNewGame(partyCode) {
      const newGameState = {
        ...gameState,
        partyCode: partyCode,
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      };
      
      db.collection("gameStates").doc(partyCode).set(newGameState)
        .then(() => {
          gameState = newGameState;
          updateGameUI();
          assignPlayers();
        });
    }
    
    // Assign players to X and O roles
    function assignPlayers() {
      if (!currentParty || !gameState) return;
      
      // Only assign if game is in progress
      if (gameState.gameStatus !== 'playing') return;
      
      // Get players who aren't assigned
      const availablePlayers = currentParty.players.filter(player => 
        player.id !== (gameState.playerX?.id || '') && 
        player.id !== (gameState.playerO?.id || '') &&
        !gameState.afkPlayers.includes(player.id)
      );
      
      if (availablePlayers.length === 0) return;
      
      // For tournaments, assign players from current match
      if (gameState.tournament.rounds.length > 0) {
        const currentRound = gameState.tournament.rounds[gameState.tournament.currentRound];
        if (currentRound && currentRound[gameState.tournament.currentMatch]) {
          const match = currentRound[gameState.tournament.currentMatch];
          
          if (!gameState.playerX && match.player1) {
            gameState.playerX = match.player1;
          }
          
          if (!gameState.playerO && match.player2) {
            gameState.playerO = match.player2;
          }
        }
      } 
      // For non-tournament games
      else {
        // Assign first available player to X if not assigned
        if (!gameState.playerX) {
          gameState.playerX = availablePlayers[0];
        } 
        // Then assign to O if not assigned
        else if (!gameState.playerO && availablePlayers.length > 0) {
          gameState.playerO = availablePlayers[0];
        }
      }
      
      // Update Firestore
      updateGameState();
    }
    
    // Update the game UI
    function updateGameUI() {
      // Update board
      gameState.board.forEach((value, index) => {
        const cell = document.querySelector(`.cell[data-index="${index}"]`);
        cell.textContent = value || '';
        cell.className = `cell ${value ? value.toLowerCase() : ''}`;
        
        // Add winning cell effect
        if (gameState.winningCells.includes(index)) {
          cell.classList.add('winning-cell');
        } else {
          cell.classList.remove('winning-cell');
        }
      });
      
      // Update status
      if (gameState.gameStatus === 'playing') {
        if (gameState.playerX && gameState.playerO) {
          gameStatus.textContent = 'Game in progress';
          playerTurn.textContent = `${gameState.currentPlayer}'s turn`;
          playerTurn.className = `player-turn ${gameState.currentPlayer.toLowerCase()}`;
        } else {
          gameStatus.textContent = 'Waiting for players...';
          playerTurn.textContent = `Need ${!gameState.playerX ? 'Player X' : 'Player O'}`;
          playerTurn.className = 'player-turn';
        }
      } else if (gameState.gameStatus === 'X_won') {
        gameStatus.textContent = 'Player X Wins!';
        playerTurn.textContent = 'Game over';
        playerTurn.className = 'player-turn';
      } else if (gameState.gameStatus === 'O_won') {
        gameStatus.textContent = 'Player O Wins!';
        playerTurn.textContent = 'Game over';
        playerTurn.className = 'player-turn';
      } else if (gameState.gameStatus === 'draw') {
        gameStatus.textContent = 'Game Draw!';
        playerTurn.textContent = 'No winner';
        playerTurn.className = 'player-turn';
      }
      
      // Update scores
      scoreX.textContent = gameState.scores.X;
      scoreO.textContent = gameState.scores.O;
      scoreDraw.textContent = gameState.scores.draw;
      
      // Update player indicators
      playerXIndicator.textContent = gameState.playerX ? gameState.playerX.name : 'Not assigned';
      playerOIndicator.textContent = gameState.playerO ? gameState.playerO.name : 'Not assigned';
    }
    
    // Update party UI
    function updatePartyUI() {
      if (!currentParty) return;
      
      partyCodeDisplay.textContent = currentParty.code;
      partyNameDisplay.textContent = currentParty.name;
      playerCount.textContent = currentParty.players.length;
      maxPlayers.textContent = currentParty.maxPlayers;
      
      // Update player list
      playerList.innerHTML = '';
      currentParty.players.forEach(player => {
        const playerItem = document.createElement('div');
        playerItem.className = 'player-item';
        
        if (gameState.afkPlayers.includes(player.id)) {
          playerItem.classList.add('afk-warning');
        }
        
        const avatar = document.createElement('div');
        avatar.className = 'player-avatar';
        avatar.textContent = player.name.charAt(0);
        
        const name = document.createElement('div');
        name.className = 'player-name';
        name.textContent = player.name;
        
        const symbol = document.createElement('div');
        symbol.className = 'player-symbol';
        
        if (gameState.playerX && player.id === gameState.playerX.id) {
          symbol.textContent = 'X';
          symbol.classList.add('x');
        } else if (gameState.playerO && player.id === gameState.playerO.id) {
          symbol.textContent = 'O';
          symbol.classList.add('o');
        }
        
        playerItem.appendChild(avatar);
        playerItem.appendChild(name);
        playerItem.appendChild(symbol);
        playerList.appendChild(playerItem);
      });
    }
    
    // Set up the game board
    function setupBoard() {
      gameBoard.querySelectorAll('.cell').forEach(cell => {
        cell.addEventListener('click', () => handleCellClick(cell));
      });
    }
    
    // Handle cell click
    function handleCellClick(cell) {
      if (gameState.gameStatus !== 'playing') {
        showNotification("Game is not active!");
        return;
      }
      
      // Check if both players are assigned
      if (!gameState.playerX || !gameState.playerO) {
        showNotification("Waiting for another player to join...");
        return;
      }
      
      const index = parseInt(cell.getAttribute('data-index'));
      
      // Check if cell is empty
      if (gameState.board[index] !== null) {
        showNotification("This cell is already taken!");
        return;
      }
      
      // Check if it's current player's turn
      if (gameState.currentPlayer === 'X' && currentUser.uid !== gameState.playerX.id) {
        showNotification("It's not your turn!");
        return;
      }
      
      if (gameState.currentPlayer === 'O' && currentUser.uid !== gameState.playerO.id) {
        showNotification("It's not your turn!");
        return;
      }
      
      // Reset AFK timer for current player
      resetAFKTimer(currentUser.uid);
      
      // Update board
      gameState.board[index] = gameState.currentPlayer;
      gameState.lastMoveTime = firebase.firestore.Timestamp.now();
      
      // Check for winner
      const winner = checkWinner();
      if (winner) {
        if (winner === 'X') {
          gameState.gameStatus = 'X_won';
          gameState.scores.X += 1;
          showNotification("Player X wins!");
          
          // For tournaments, record winner
          if (gameState.tournament.rounds.length > 0) {
            recordMatchWinner(gameState.playerX);
          }
        } else if (winner === 'O') {
          gameState.gameStatus = 'O_won';
          gameState.scores.O += 1;
          showNotification("Player O wins!");
          
          // For tournaments, record winner
          if (gameState.tournament.rounds.length > 0) {
            recordMatchWinner(gameState.playerO);
          }
        }
      } 
      // Check for draw
      else if (gameState.board.every(cell => cell !== null)) {
        gameState.gameStatus = 'draw';
        gameState.scores.draw += 1;
        showNotification("It's a draw!");
        
        // For tournaments, move to next match
        if (gameState.tournament.rounds.length > 0) {
          advanceTournament(null);
        }
      } 
      // Continue game
      else {
        gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
      }
      
      // Update Firestore
      updateGameState();
    }
    
    // Record tournament match winner
    function recordMatchWinner(winner) {
      if (gameState.tournament.rounds.length === 0) return;
      
      const currentRound = gameState.tournament.currentRound;
      const currentMatch = gameState.tournament.currentMatch;
      
      if (gameState.tournament.rounds[currentRound] && 
          gameState.tournament.rounds[currentRound][currentMatch]) {
        gameState.tournament.rounds[currentRound][currentMatch].winner = winner;
      }
      
      advanceTournament(winner);
    }
    
    // Advance to next tournament match
    function advanceTournament(winner) {
      const currentRound = gameState.tournament.currentRound;
      const currentMatch = gameState.tournament.currentMatch;
      
      // Check if there are more matches in this round
      if (currentMatch < gameState.tournament.rounds[currentRound].length - 1) {
        gameState.tournament.currentMatch++;
      } 
      // Otherwise, move to next round
      else {
        // Create next round if needed
        if (gameState.tournament.rounds.length - 1 === currentRound) {
          const winners = gameState.tournament.rounds[currentRound].map(match => match.winner);
          if (winners.filter(w => w).length > 1) {
            const nextRound = [];
            for (let i = 0; i < winners.length; i += 2) {
              if (i + 1 < winners.length) {
                nextRound.push({
                  player1: winners[i],
                  player2: winners[i + 1],
                  winner: null
                });
              }
            }
            gameState.tournament.rounds.push(nextRound);
            gameState.tournament.currentRound++;
            gameState.tournament.currentMatch = 0;
          }
        } 
        // Already have next round
        else if (gameState.tournament.rounds.length > currentRound + 1) {
          gameState.tournament.currentRound++;
          gameState.tournament.currentMatch = 0;
        }
      }
      
      // Reset game for next match
      resetGameForNextMatch();
    }
    
    // Reset game for next match
    function resetGameForNextMatch() {
      gameState.board = Array(9).fill(null);
      gameState.currentPlayer = 'X';
      gameState.gameStatus = 'playing';
      gameState.winningCells = [];
      gameState.playerX = null;
      gameState.playerO = null;
      
      updateGameState();
    }
    
    // Check for winner
    function checkWinner() {
      const winPatterns = [
        [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
        [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
        [0, 4, 8], [2, 4, 6]             // diagonals
      ];
      
      for (const pattern of winPatterns) {
        const [a, b, c] = pattern;
        if (
          gameState.board[a] && 
          gameState.board[a] === gameState.board[b] && 
          gameState.board[a] === gameState.board[c]
        ) {
          gameState.winningCells = pattern;
          return gameState.board[a];
        }
      }
      
      gameState.winningCells = [];
      return null;
    }
    
    // Update game state in Firestore
    function updateGameState() {
      db.collection("gameStates").doc(currentParty.code).set(gameState, { merge: true })
        .catch(error => {
          console.error("Error updating game state: ", error);
          showNotification("Error updating game, please try again");
        });
    }
    
    // Reset the game
    function resetGame() {
      // Only host can reset the game
      if (currentUser.uid !== currentParty.hostId) {
        showNotification('Only the host can reset the game!');
        return;
      }
      
      gameState.board = Array(9).fill(null);
      gameState.currentPlayer = 'X';
      gameState.gameStatus = 'playing';
      gameState.winningCells = [];
      
      // Rotate players if both are present
      if (gameState.playerX && gameState.playerO) {
        const temp = gameState.playerX;
        gameState.playerX = gameState.playerO;
        gameState.playerO = temp;
      }
      
      updateGameState();
      showNotification('Game reset!');
    }
    
    // Leave the game and return to lobby
    function leaveGame() {
      if (!currentParty || !currentUser) {
        window.location.href = 'index.html';
        return;
      }
      
      const userData = { id: currentUser.uid, name: currentUser.displayName };
      
      if (currentUser.uid === currentParty.hostId) {
        // Host leaves: delete party and game state
        db.collection("parties").doc(currentParty.code).delete()
          .then(() => {
            db.collection("gameStates").doc(currentParty.code).delete().catch(() => {});
            cleanupAndRedirect();
            showNotification('Party deleted!');
          })
          .catch(error => {
            console.error("Error deleting party: ", error);
            cleanupAndRedirect();
          });
      } else {
        // Non-host: remove from party and update game state
        db.collection("parties").doc(currentParty.code).update({
          players: firebase.firestore.FieldValue.arrayRemove(userData)
        })
        .then(() => {
          // Remove from game state if assigned
          if (gameState.playerX && currentUser.uid === gameState.playerX.id) {
            gameState.playerX = null;
          }
          if (gameState.playerO && currentUser.uid === gameState.playerO.id) {
            gameState.playerO = null;
          }
          updateGameState();
          cleanupAndRedirect();
          showNotification('Left party!');
        })
        .catch(error => {
          console.error("Error leaving party: ", error);
          cleanupAndRedirect();
        });
      }
    }
    
    function cleanupAndRedirect() {
      clearAFKTimers();
      if (partyListener) partyListener();
      if (gameListener) gameListener();
      window.location.href = 'index.html';
    }
    
    // Initialize the game when page loads
    window.onload = initGame;
  </script>
</body>
</html>
